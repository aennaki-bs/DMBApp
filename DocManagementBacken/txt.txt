appsettings.json:

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"}},
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=DocManagementDB;Trusted_Connection=True;Encrypt=False;TrustServerCertificate=True;MultipleActiveResultSets=true;"},
  "JwtSettings": {
  "SecretKey": "lLkWX3ZoWI4wgjM27n6CGwiWqpQl14lIrlYwll5Wyour-very-secure-secret-key",
  "Issuer": "http://0.0.0.0:5204",
  "Audience": "http://0.0.0.0:5173",
  "ExpiryMinutes": 60}
}


Program.cs:
using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using DocManagementBackend.Data;
using System.Text;
using DotNetEnv;

Env.Load();
var builder = WebApplication.CreateBuilder(args);
builder.WebHost.UseUrls("http://0.0.0.0:5204");
var jwtSettings = builder.Configuration.GetSection("JwtSettings");
var secretKey = jwtSettings["SecretKey"];
if (string.IsNullOrEmpty(secretKey)) {throw new InvalidOperationException("JWT configuration is missing.");}
var key = Encoding.UTF8.GetBytes(secretKey);
builder.Services.AddAuthentication(options =>
{options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(options =>{options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(key), ValidateIssuer = true, ValidIssuer = jwtSettings["Issuer"], ValidateAudience = true, ValidAudience = jwtSettings["Audience"], ValidateLifetime = true };});
builder.Services.AddCors(options =>{options.AddPolicy("AllowAll", policy => policy.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());});
builder.Services.AddControllers();
builder.Services.AddSwaggerGen();
builder.Services.AddAuthorization();
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));
var app = builder.Build();
if (app.Environment.IsDevelopment()){app.UseSwagger(); app.UseSwaggerUI();}
app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.UseCors("AllowAll");
app.Run();


Models/user.cs:

using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;

namespace DocManagementBackend.Models{
    public class User{
        [Key]
        public int Id { get; set; }
        [Required]
        [EmailAddress]
        public string Email { get; set; } = string.Empty;
        [Required]
        [StringLength(100)]
        public string Username { get; set; } = string.Empty;
        [Required]
        public string PasswordHash { get; set; } = string.Empty;
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public bool IsEmailConfirmed { get; set; } = false;
        public string? EmailVerificationCode { get; set; }
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public bool IsActive { get; set; } = false;
        public DateTime? LastLogin { get; set; }
        public string? ProfilePicture { get; set; }
        public string? BackgroundPicture { get; set; }
        public int RoleId { get; set; }
        [ForeignKey("RoleId")]
        public required Role Role { get; set; }
        [JsonIgnore]
        public ICollection<LogHistory> LogHistories { get; set; } = new List<LogHistory>();
        [JsonIgnore]
        public ICollection<Document> Documents { get; set; } = new List<Document>();}
    public class Role{
        [Key]
        public int Id { get; set; }
        [Required]
        public string RoleName { get; set; } = string.Empty;
        public bool IsAdmin { get; set; } = false;
        public bool IsSimpleUser { get; set; } = false;
        public bool IsFullUser { get; set; } = false;
        [JsonIgnore]
        public ICollection<User> Users { get; set; } = new List<User>();}
    public class LogHistory{
        [Key]
        public int Id { get; set; }
        [Required]
        public int UserId { get; set; }
        [ForeignKey("UserId")]
        public required User User { get; set; }
        [Required]
        public DateTime Timestamp { get; set; }
        [Required]
        public int ActionType { get; set; } // 1 for Login, 0 for Logout}
    public class Document{
        [Key]
        public int Id { get; set; }
        [Required]
        public string Title { get; set; } = string.Empty;
        public string? Content { get; set; }
        [Required]
        public int CreatedByUserId { get; set; }
        [ForeignKey("CreatedByUserId")]
        public required User CreatedBy { get; set; }
        [Required]
        public int Status { get; set; } // 0 for Open, 1 for Posted
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;}
}


Controllers/AuthController.cs:

using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Net.Mail;
using DocManagementBackend.Data;
using DocManagementBackend.Models;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace DocManagementBackend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase{private readonly ApplicationDbContext _context;
        private readonly IConfiguration _config;
        public AuthController(ApplicationDbContext context, IConfiguration config){ _context = context;
            _config = config;}
        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] User user){
            if (await _context.Users.AnyAsync(u => u.Email == user.Email))
                return BadRequest("Email is already in use.");
            if (await _context.Users.AnyAsync(u => u.Username == user.Username))
                return BadRequest("Username is already in use.");
            if (!IsValidPassword(user.PasswordHash))
                return BadRequest("Password must be at least 8 characters long and include an uppercase letter, a lowercase letter, a digit, and a special character.");
            user.EmailVerificationCode = new Random().Next(100000, 999999).ToString();
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(user.PasswordHash); // Hash password
            user.IsActive = false;
            user.IsEmailConfirmed = false;
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
            SendEmail(user.Email, "Email Verification", $"Your verification code is: {user.EmailVerificationCode}");
            return Ok("Registration successful! Please check your email for the verification code.");}
        private bool IsValidPassword(string password){return password.Length >= 8 &&
                   password.Any(char.IsLower) &&
                   password.Any(char.IsUpper) &&
                   password.Any(char.IsDigit) &&
                   password.Any(ch => !char.IsLetterOrDigit(ch));}
        private void SendEmail(string to, string subject, string body){
            string? emailAddress = Environment.GetEnvironmentVariable("EMAIL_ADDRESS");
            string? emailPassword = Environment.GetEnvironmentVariable("EMAIL_PASSWORD");
            if (string.IsNullOrEmpty(emailAddress) || string.IsNullOrEmpty(emailPassword)){
                throw new InvalidOperationException("Email address or password is not set in environment variables.");}
            using (var smtp = new SmtpClient("smtp.gmail.com", 587)){
                smtp.Credentials = new System.Net.NetworkCredential(emailAddress, emailPassword);
                smtp.EnableSsl = true;
                var message = new MailMessage();
                message.To.Add(to);
                message.Subject = subject;
                message.Body = body;
                message.IsBodyHtml = true;
                message.From = new MailAddress(emailAddress);
                smtp.Send(message);}}
        [HttpPost("verify-email")]
        public async Task<IActionResult> VerifyEmail([FromBody] VerifyEmailRequest request){
            var user = await _context.Users.FirstOrDefaultAsync(u => u.Email == request.Email);
            if (user == null)
                return NotFound("User not found.");
            if (user.EmailVerificationCode != request.VerificationCode)
                return BadRequest("Invalid verification code.");
            user.IsEmailConfirmed = true;
            user.IsActive = true; // Activate account after verification
            user.EmailVerificationCode = null; // Clear token after use
            await _context.SaveChangesAsync();
            return Ok("Email verified successfully!");}
        public class VerifyEmailRequest{
            public string? Email { get; set; }
            public string? VerificationCode { get; set; }}
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginRequest model){
            var user = await _context.Users
                .FirstOrDefaultAsync(u => u.Email == model.EmailOrUsername || u.Username == model.EmailOrUsername);
            if (user == null || !BCrypt.Net.BCrypt.Verify(model.Password, user.PasswordHash))
                return Unauthorized("Invalid credentials");
            if (!user.IsEmailConfirmed)
                return Unauthorized("Please verify your email before logging in.");
            var logEntry = new LogHistory{
                UserId = user.Id,
                User = user,
                Timestamp = DateTime.UtcNow,
                ActionType = 1 // Login action};
            _context.LogHistories.Add(logEntry);
            user.LastLogin = DateTime.UtcNow;
            _context.SaveChanges();
            var token = GenerateJwtToken(user);
            return Ok(new { Token = token });
        }
        private string GenerateJwtToken(User user){
            var jwtSettings = _config.GetSection("JwtSettings");
            var secretKey = jwtSettings["SecretKey"];
            if (string.IsNullOrEmpty(secretKey)) {throw new InvalidOperationException("JWT configuration is missing.");}
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
            var claims = new[]{new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()), new Claim(JwtRegisteredClaimNames.Email, user.Email), new Claim("Username", user.Username)};
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expMinutes = jwtSettings["ExpiryMinutes"];
            if (string.IsNullOrEmpty(expMinutes)) {throw new InvalidOperationException("ExpiryMinutes is missing.");}
            var token = new JwtSecurityToken(issuer: jwtSettings["Issuer"], audience: jwtSettings["Audience"], claims: claims, expires: DateTime.UtcNow.AddMinutes(int.Parse(expMinutes)), signingCredentials: creds);
            return new JwtSecurityTokenHandler().WriteToken(token);}
        [HttpPost("logout")]
        public async Task<IActionResult> Logout([FromBody] LogoutRequest model){
            try{var user = await _context.Users.FindAsync(model.UserId);
                if (user == null) {return NotFound(new { message = "User not found." });}
                var logHistory = new LogHistory {UserId = model.UserId, User = user, Timestamp = DateTime.UtcNow, ActionType = 0 // 0 = Logout};
                _context.LogHistories.Add(logHistory);
                await _context.SaveChangesAsync();
                return Ok(new { message = "Logout recorded successfully." });}
            catch (Exception ex){return StatusCode(500, new { message = "An error occurred.", error = ex.Message });}}
    }
}
public class LoginRequest{public string EmailOrUsername { get; set; } = string.Empty;
    public string Password { get; set; } = string.Empty;}

public class LogoutRequest{public int UserId { get; set; }}


Controllers/DocumentsController.cs:

using Microsoft.AspNetCore.Mvc;
using DocManagementBackend.Models;
using DocManagementBackend.Data;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using System.Security.Claims;

namespace DocManagementBackend.Controllers
{
    [Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class DocumentsController : ControllerBase
    {private readonly ApplicationDbContext _context;
        public DocumentsController(ApplicationDbContext context){_context = context;}
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Document>>> GetDocuments()
        {var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userIdClaim == null){return Unauthorized("User ID claim is missing.");}
            var userId = int.Parse(userIdClaim);
            var postedDocuments = await _context.Documents
                .Where(d => d.Status == 1)
                .ToListAsync();
            var openDocuments = await _context.Documents
                .Where(d => d.Status == 0 && d.CreatedByUserId == userId)
                .ToListAsync();
            var result = postedDocuments.Concat(openDocuments).ToList();
            return result;}
        [HttpGet("{id}")]
        public async Task<ActionResult<Document>> GetDocument(int id){var document = await _context.Documents.FindAsync(id);
            if (document == null){    return NotFound();}
            return document;}
        [HttpPost]
        public async Task<ActionResult<Document>> CreateDocument(Document document){document.CreatedAt = DateTime.UtcNow;
            document.Status = 0; // Default status is Open
            _context.Documents.Add(document);
            await _context.SaveChangesAsync();
            return CreatedAtAction(nameof(GetDocument), new { id = document.Id }, document);}
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateDocument(int id, Document document){if (id != document.Id){return BadRequest();}
            var existingDocument = await _context.Documents.FindAsync(id);
            if (existingDocument == null) {return NotFound();}
            if (existingDocument.Status != 0){return BadRequest("Only documents with status 'Open' can be edited.");}
            existingDocument.Title = document.Title;
            existingDocument.Content = document.Content;
            _context.Entry(existingDocument).State = EntityState.Modified;
            try{await _context.SaveChangesAsync();}
            catch (DbUpdateConcurrencyException){if (!_context.Documents.Any(d => d.Id == id)){return NotFound();}
                else{throw;}}
            return NoContent();}
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteDocument(int id){ var document = await _context.Documents.FindAsync(id);
            if (document == null){return NotFound();}
            if (document.Status != 0) { return BadRequest("Only documents with status 'Open' can be deleted.");}
            _context.Documents.Remove(document);
            await _context.SaveChangesAsync();
            return NoContent();}}
}


Data/ApllicationBdContext.cs:

using Microsoft.EntityFrameworkCore;
using DocManagementBackend.Models;

namespace DocManagementBackend.Data
{public class ApplicationDbContext : DbContext
    {public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }
        public DbSet<User> Users { get; set; }
        public DbSet<LogHistory> LogHistories { get; set; }
        public DbSet<Document> Documents { get; set; }
        public DbSet<Role> Roles { get; set; }
        protected override void OnModelCreating(ModelBuilder modelBuilder){modelBuilder.Entity<Role>().HasData(new Role { Id = 1, RoleName = "Admin", IsAdmin = true },
                new Role { Id = 2, RoleName = "SimpleUser", IsSimpleUser = true },
                new Role { Id = 3, RoleName = "FullUser", IsFullUser = true });}}
}
